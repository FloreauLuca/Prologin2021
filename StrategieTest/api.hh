// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2012-2020 Association Prologin <association@prologin.org>

// This file contains all the API functions for the C++ language, and all the
// constants, enumerations and structures.
// This file was generated by stechec2-generator. DO NOT EDIT.

#pragma once

#include <string>
#include <vector>

/// Nombre de tours à jouer avant la fin de la partie.
#define NB_TOURS 200

/// Nombre de pandas par joueur.
#define NB_PANDAS 2

/// Nombre de tours nécessaires pour faire tomber un bébé panda.
#define NB_TOURS_PERTE_BEBE 3

/// Valeur max d'un pont (les valeurs sont comprises entre 1 et cette constante
/// inclus).
#define VALEUR_MAX_PONT 6

/// Nombre de points obtenus à la capture d'un bébé pandas.
#define NB_POINTS_CAPTURE_BEBE 10

/// Types de cases
typedef enum case_type
{
    LIBRE, ///< Case libre
    OBSTACLE, ///< Obstacle
    PONT, ///< Pont
    BEBE, ///< Bébé panda
} case_type;

/// Directions cardinales
typedef enum direction
{
    NORD_EST, ///< Direction : nord-est
    SUD_EST, ///< Direction : sud-est
    SUD, ///< Direction : sud
    SUD_OUEST, ///< Direction : sud-ouest
    NORD_OUEST, ///< Direction : nord-ouest
    NORD, ///< Direction : nord
} direction;

/// Erreurs possibles
typedef enum erreur
{
    OK, ///< L'action s'est effectuée avec succès.
    POSITION_INVALIDE, ///< La position spécifiée n'est pas sur la rivière.
    POSITION_OBSTACLE, ///< La position spécifiée est un obstacle.
    MAUVAIS_NOMBRE, ///< La hauteur de la position spécifiée ne correspond pas.
    DEPLACEMENT_HORS_LIMITES, ///< Ce déplacement fait sortir un panda des limites de la rivière.
    DIRECTION_INVALIDE, ///< La direction spécifiée n'existe pas.
    MOUVEMENT_INVALIDE, ///< Le panda ne peut pas se déplacer dans cette direction.
    POSE_INVALIDE, ///< Le pont ne peut pas être placé a cette position et dans cette direction.
    ID_PANDA_INVALIDE, ///< Le panda spécifié n'existe pas.
    ACTION_DEJA_EFFECTUEE, ///< Une action a déjà été effectuée ce tour.
    DRAPEAU_INVALIDE, ///< Le drapeau spécifié n'existe pas.
    DEPLACEMENT_EN_ARRIERE, ///< La panda c'est déjà déplacé sur cette case.
} erreur;

/// Types d'actions
typedef enum action_type
{
    ACTION_DEPLACER, ///< Action ``deplacer``.
    ACTION_POSER, ///< Action ``poser``.
} action_type;

/// Types de drapeau de débug
typedef enum debug_drapeau
{
    AUCUN_DRAPEAU, ///< Aucun drapeau, enlève le drapeau présent
    DRAPEAU_BLEU, ///< Drapeau bleu
    DRAPEAU_VERT, ///< Drapeau vert
    DRAPEAU_ROUGE, ///< Drapeau rouge
} debug_drapeau;

/// Position du panda.
typedef struct position
{
    int x; ///< Coordonnée : x
    int y; ///< Coordonnée : y
} position;

/// Case type pont, contient la case de début et de fin. La case de début a une
/// valeur se décrémentant, celle de fin s'incrémente.
typedef struct pont_type
{
    position debut_pos; ///< Position de la case de début
    position fin_pos; ///< Position de la case de fin
    int debut_val; ///< Valeur de la case de début
    int fin_val; ///< Valeur de la case de début
} pont_type;

/// Panda et son joueur
typedef struct panda_info
{
    position panda_pos; ///< Position du panda
    int id_joueur; ///< Identifiant du joueur qui contrôle le panda
    int id_panda; ///< Identifiant du panda relatif au joueur
    int num_bebes; ///< Nombre de bébés qui sont portés par le panda parent
} panda_info;

/// Bébé panda à ramener.
typedef struct bebe_info
{
    position bebe_pos; ///< Position du bébé panda
    int id_bebe_joueur; ///< Identifiant du joueur qui peut saver le bébé
} bebe_info;

/// Information sur un tour particulier.
typedef struct tour_info
{
    int id_panda_joue; ///< Identifiant du panda qui joue
    int id_tour; ///< Identifiant unique du tour (compteur)
} tour_info;

/// Information sur la carte de la partie en cours.
typedef struct carte_info
{
    int taille_x; ///< La taille de la carte pour les coordonnées x [0; taille_x[
    int taille_y; ///< La taille de la carte pour les coordonnées y [0; taille_y[
} carte_info;

/// Action représentée dans l'historique.
typedef struct action_hist
{
    action_type type_action; ///< Type de l'action
    int action_id_panda; ///< Identifiant du panda concerné par l'action
    direction dir; ///< Direction visée par le panda durant le déplacement
    int valeur_debut; ///< Valeur au début du pont posé (de 1 à 6 inclus)
    int valeur_fin; ///< Valeur à la fin du pont posé (de 1 à 6 inclus)
    position pos_debut; ///< Position du début du pont posé
    position pos_fin; ///< Position de la fin du pont posé
} action_hist;

/// Déplace le panda ``id_panda`` sur le pont choisi.
erreur deplacer(direction dir);

/// Pose un pont dans la direction choisie à partir du panda ``id_panda``.
erreur poser(position position_debut, direction dir, int pont_debut, int pont_fin);

/// Affiche le drapeau spécifié sur la case indiquée
erreur debug_afficher_drapeau(position pos, debug_drapeau drapeau);

/// Renvoie le type d'une case donnée.
case_type type_case(position pos);

/// Renvoie le numéro du joueur à qui appartient panda sur la case indiquée.
/// Renvoie -1 s'il n'y a pas de panda ou si la position est invalide.
int panda_sur_case(position pos);

/// Renvoie le numéro du joueur à qui appartient le bébé panda sur la case
/// indiquée. Renvoie -1 s'il n'y a pas de bébé panda ou si la position est
/// invalide.
int bebe_panda_sur_case(position pos);

/// Indique la position du panda sur la rivière désigné par le numéro
/// ``id_panda`` appartenant au joueur ``id_joueur``. Si la description du
/// panda est incorrecte, la position (-1, -1) est renvoyée.
position position_panda(int id_joueur, int id_panda);

/// Renvoie les informations relatives au pont situé à cette position. Le pont
/// est constitué de deux cases. Si aucun pont n'est placé à cette position ou
/// si la position est invalide, les membres debut_val et fin_val de la
/// structure ``pont_type`` renvoyée sont initialisés à -1.
pont_type info_pont(position pos);

/// Renvoie la description d'un panda en fonction d'une position donnée. Si le
/// panda n'est pas présent sur la carte, ou si la position est invalide, tous
/// les membres de la structure ``panda_info`` renvoyée sont initialisés à -1.
panda_info info_panda(position pos);

/// Renvoie la liste de tous les pandas présents durant la partie.
std::vector<panda_info> liste_pandas();

/// Renvoie la liste de tous les bébés présents sur la carte, et et pas encore
/// sauvés.
std::vector<bebe_info> liste_bebes();

/// Renvoie la liste de toutes les positions adjacentes à la position donnée.
std::vector<position> positions_adjacentes(position pos);

/// Renvoie la position relative à la direction donnée par rapport à une
/// position d'origine. Si une telle position serait invalide, la position {-1,
/// -1} est renvoyée.
position position_dans_direction(position pos, direction dir);

/// Renvoie la direction telle que position_dans_direction(origine, cible) ==
/// direction. Si aucune telle direction n'existe, -1 est renvoyée.
int direction_entre_positions(position origine, position cible);

/// Renvoie la liste des actions effectuées par l’adversaire durant son tour,
/// dans l'ordre chronologique. Les actions de débug n'apparaissent pas dans
/// cette liste.
std::vector<action_hist> historique();

/// Renvoie le score du joueur ``id_joueur``. Renvoie -1 si le joueur est
/// invalide.
int score(int id_joueur);

/// Renvoie votre numéro de joueur.
int moi();

/// Renvoie le numéro de joueur de votre adversaire.
int adversaire();

/// Renvoie le tour actuel.
tour_info info_tour();

/// Renvoie la carte pour la partie en cours.
carte_info info_carte();

/// Affiche le contenu d'une valeur de type case_type
void afficher_case_type(case_type v);

/// Affiche le contenu d'une valeur de type direction
void afficher_direction(direction v);

/// Affiche le contenu d'une valeur de type erreur
void afficher_erreur(erreur v);

/// Affiche le contenu d'une valeur de type action_type
void afficher_action_type(action_type v);

/// Affiche le contenu d'une valeur de type debug_drapeau
void afficher_debug_drapeau(debug_drapeau v);

/// Affiche le contenu d'une valeur de type position
void afficher_position(position v);

/// Affiche le contenu d'une valeur de type pont_type
void afficher_pont_type(pont_type v);

/// Affiche le contenu d'une valeur de type panda_info
void afficher_panda_info(panda_info v);

/// Affiche le contenu d'une valeur de type bebe_info
void afficher_bebe_info(bebe_info v);

/// Affiche le contenu d'une valeur de type tour_info
void afficher_tour_info(tour_info v);

/// Affiche le contenu d'une valeur de type carte_info
void afficher_carte_info(carte_info v);

/// Affiche le contenu d'une valeur de type action_hist
void afficher_action_hist(action_hist v);

// -----
// API ends here, you can stop reading now.
// The rest of the file is generated operators for the structs defined above.
// -----

namespace std
{
template <typename T>
struct hash<std::vector<T>>
{
    std::size_t operator()(const std::vector<T>& v) const
    {
        std::size_t res = v.size();
        for (const auto& e : v)
            res ^= std::hash<T>()(e) + 0x9e3779b9 + (res << 6) + (res >> 2);
        return res;
    }
};
} // namespace std

inline bool operator==(const position& a, const position& b)
{
    if (a.x != b.x)
        return false;
    if (a.y != b.y)
        return false;
    return true;
}

inline bool operator!=(const position& a, const position& b)
{
    return !(a == b);
}

inline bool operator<(const position& a, const position& b)
{
    if (a.x < b.x)
        return true;
    if (a.x > b.x)
        return false;
    if (a.y < b.y)
        return true;
    if (a.y > b.y)
        return false;
    return false;
}

inline bool operator>(const position& a, const position& b)
{
    if (a.x > b.x)
        return true;
    if (a.x < b.x)
        return false;
    if (a.y > b.y)
        return true;
    if (a.y < b.y)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<position>
{
    std::size_t operator()(const position& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.x);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.y);
        return res;
    }
};
} // namespace std
inline bool operator==(const pont_type& a, const pont_type& b)
{
    if (a.debut_pos != b.debut_pos)
        return false;
    if (a.fin_pos != b.fin_pos)
        return false;
    if (a.debut_val != b.debut_val)
        return false;
    if (a.fin_val != b.fin_val)
        return false;
    return true;
}

inline bool operator!=(const pont_type& a, const pont_type& b)
{
    return !(a == b);
}

inline bool operator<(const pont_type& a, const pont_type& b)
{
    if (a.debut_pos < b.debut_pos)
        return true;
    if (a.debut_pos > b.debut_pos)
        return false;
    if (a.fin_pos < b.fin_pos)
        return true;
    if (a.fin_pos > b.fin_pos)
        return false;
    if (a.debut_val < b.debut_val)
        return true;
    if (a.debut_val > b.debut_val)
        return false;
    if (a.fin_val < b.fin_val)
        return true;
    if (a.fin_val > b.fin_val)
        return false;
    return false;
}

inline bool operator>(const pont_type& a, const pont_type& b)
{
    if (a.debut_pos > b.debut_pos)
        return true;
    if (a.debut_pos < b.debut_pos)
        return false;
    if (a.fin_pos > b.fin_pos)
        return true;
    if (a.fin_pos < b.fin_pos)
        return false;
    if (a.debut_val > b.debut_val)
        return true;
    if (a.debut_val < b.debut_val)
        return false;
    if (a.fin_val > b.fin_val)
        return true;
    if (a.fin_val < b.fin_val)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<pont_type>
{
    std::size_t operator()(const pont_type& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.debut_pos);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.fin_pos);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.debut_val);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.fin_val);
        return res;
    }
};
} // namespace std
inline bool operator==(const panda_info& a, const panda_info& b)
{
    if (a.panda_pos != b.panda_pos)
        return false;
    if (a.id_joueur != b.id_joueur)
        return false;
    if (a.id_panda != b.id_panda)
        return false;
    if (a.num_bebes != b.num_bebes)
        return false;
    return true;
}

inline bool operator!=(const panda_info& a, const panda_info& b)
{
    return !(a == b);
}

inline bool operator<(const panda_info& a, const panda_info& b)
{
    if (a.panda_pos < b.panda_pos)
        return true;
    if (a.panda_pos > b.panda_pos)
        return false;
    if (a.id_joueur < b.id_joueur)
        return true;
    if (a.id_joueur > b.id_joueur)
        return false;
    if (a.id_panda < b.id_panda)
        return true;
    if (a.id_panda > b.id_panda)
        return false;
    if (a.num_bebes < b.num_bebes)
        return true;
    if (a.num_bebes > b.num_bebes)
        return false;
    return false;
}

inline bool operator>(const panda_info& a, const panda_info& b)
{
    if (a.panda_pos > b.panda_pos)
        return true;
    if (a.panda_pos < b.panda_pos)
        return false;
    if (a.id_joueur > b.id_joueur)
        return true;
    if (a.id_joueur < b.id_joueur)
        return false;
    if (a.id_panda > b.id_panda)
        return true;
    if (a.id_panda < b.id_panda)
        return false;
    if (a.num_bebes > b.num_bebes)
        return true;
    if (a.num_bebes < b.num_bebes)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<panda_info>
{
    std::size_t operator()(const panda_info& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.panda_pos);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.id_joueur);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.id_panda);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.num_bebes);
        return res;
    }
};
} // namespace std
inline bool operator==(const bebe_info& a, const bebe_info& b)
{
    if (a.bebe_pos != b.bebe_pos)
        return false;
    if (a.id_bebe_joueur != b.id_bebe_joueur)
        return false;
    return true;
}

inline bool operator!=(const bebe_info& a, const bebe_info& b)
{
    return !(a == b);
}

inline bool operator<(const bebe_info& a, const bebe_info& b)
{
    if (a.bebe_pos < b.bebe_pos)
        return true;
    if (a.bebe_pos > b.bebe_pos)
        return false;
    if (a.id_bebe_joueur < b.id_bebe_joueur)
        return true;
    if (a.id_bebe_joueur > b.id_bebe_joueur)
        return false;
    return false;
}

inline bool operator>(const bebe_info& a, const bebe_info& b)
{
    if (a.bebe_pos > b.bebe_pos)
        return true;
    if (a.bebe_pos < b.bebe_pos)
        return false;
    if (a.id_bebe_joueur > b.id_bebe_joueur)
        return true;
    if (a.id_bebe_joueur < b.id_bebe_joueur)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<bebe_info>
{
    std::size_t operator()(const bebe_info& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.bebe_pos);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.id_bebe_joueur);
        return res;
    }
};
} // namespace std
inline bool operator==(const tour_info& a, const tour_info& b)
{
    if (a.id_panda_joue != b.id_panda_joue)
        return false;
    if (a.id_tour != b.id_tour)
        return false;
    return true;
}

inline bool operator!=(const tour_info& a, const tour_info& b)
{
    return !(a == b);
}

inline bool operator<(const tour_info& a, const tour_info& b)
{
    if (a.id_panda_joue < b.id_panda_joue)
        return true;
    if (a.id_panda_joue > b.id_panda_joue)
        return false;
    if (a.id_tour < b.id_tour)
        return true;
    if (a.id_tour > b.id_tour)
        return false;
    return false;
}

inline bool operator>(const tour_info& a, const tour_info& b)
{
    if (a.id_panda_joue > b.id_panda_joue)
        return true;
    if (a.id_panda_joue < b.id_panda_joue)
        return false;
    if (a.id_tour > b.id_tour)
        return true;
    if (a.id_tour < b.id_tour)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<tour_info>
{
    std::size_t operator()(const tour_info& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.id_panda_joue);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.id_tour);
        return res;
    }
};
} // namespace std
inline bool operator==(const carte_info& a, const carte_info& b)
{
    if (a.taille_x != b.taille_x)
        return false;
    if (a.taille_y != b.taille_y)
        return false;
    return true;
}

inline bool operator!=(const carte_info& a, const carte_info& b)
{
    return !(a == b);
}

inline bool operator<(const carte_info& a, const carte_info& b)
{
    if (a.taille_x < b.taille_x)
        return true;
    if (a.taille_x > b.taille_x)
        return false;
    if (a.taille_y < b.taille_y)
        return true;
    if (a.taille_y > b.taille_y)
        return false;
    return false;
}

inline bool operator>(const carte_info& a, const carte_info& b)
{
    if (a.taille_x > b.taille_x)
        return true;
    if (a.taille_x < b.taille_x)
        return false;
    if (a.taille_y > b.taille_y)
        return true;
    if (a.taille_y < b.taille_y)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<carte_info>
{
    std::size_t operator()(const carte_info& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.taille_x);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.taille_y);
        return res;
    }
};
} // namespace std
inline bool operator==(const action_hist& a, const action_hist& b)
{
    if (a.type_action != b.type_action)
        return false;
    if (a.action_id_panda != b.action_id_panda)
        return false;
    if (a.dir != b.dir)
        return false;
    if (a.valeur_debut != b.valeur_debut)
        return false;
    if (a.valeur_fin != b.valeur_fin)
        return false;
    if (a.pos_debut != b.pos_debut)
        return false;
    if (a.pos_fin != b.pos_fin)
        return false;
    return true;
}

inline bool operator!=(const action_hist& a, const action_hist& b)
{
    return !(a == b);
}

inline bool operator<(const action_hist& a, const action_hist& b)
{
    if (a.type_action < b.type_action)
        return true;
    if (a.type_action > b.type_action)
        return false;
    if (a.action_id_panda < b.action_id_panda)
        return true;
    if (a.action_id_panda > b.action_id_panda)
        return false;
    if (a.dir < b.dir)
        return true;
    if (a.dir > b.dir)
        return false;
    if (a.valeur_debut < b.valeur_debut)
        return true;
    if (a.valeur_debut > b.valeur_debut)
        return false;
    if (a.valeur_fin < b.valeur_fin)
        return true;
    if (a.valeur_fin > b.valeur_fin)
        return false;
    if (a.pos_debut < b.pos_debut)
        return true;
    if (a.pos_debut > b.pos_debut)
        return false;
    if (a.pos_fin < b.pos_fin)
        return true;
    if (a.pos_fin > b.pos_fin)
        return false;
    return false;
}

inline bool operator>(const action_hist& a, const action_hist& b)
{
    if (a.type_action > b.type_action)
        return true;
    if (a.type_action < b.type_action)
        return false;
    if (a.action_id_panda > b.action_id_panda)
        return true;
    if (a.action_id_panda < b.action_id_panda)
        return false;
    if (a.dir > b.dir)
        return true;
    if (a.dir < b.dir)
        return false;
    if (a.valeur_debut > b.valeur_debut)
        return true;
    if (a.valeur_debut < b.valeur_debut)
        return false;
    if (a.valeur_fin > b.valeur_fin)
        return true;
    if (a.valeur_fin < b.valeur_fin)
        return false;
    if (a.pos_debut > b.pos_debut)
        return true;
    if (a.pos_debut < b.pos_debut)
        return false;
    if (a.pos_fin > b.pos_fin)
        return true;
    if (a.pos_fin < b.pos_fin)
        return false;
    return false;
}

namespace std
{
template <>
struct hash<action_hist>
{
    std::size_t operator()(const action_hist& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<action_type>()(s.type_action);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.action_id_panda);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<direction>()(s.dir);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.valeur_debut);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.valeur_fin);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.pos_debut);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<position>()(s.pos_fin);
        return res;
    }
};
} // namespace std

extern "C"
{
    void partie_init();
    void jouer_tour();
    void partie_fin();
}
